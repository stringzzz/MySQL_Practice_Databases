[NULL Functions]

If a field has optional fields, can automatically put NULL into one that is unused.

Such as:

First Name 				[            ]
Middle Name (optional) 	[            ]
LAst Name 				[            ]

--------------------------------------------------

Replace values:

ISNULL

Seems to be a boolean function in MySQL:

SELECT ISNULL(NULL);
+--------------+
| ISNULL(NULL) |
+--------------+
|            1 |
+--------------+

SELECT ISNULL('not null');
+--------------------+
| ISNULL('not null') |
+--------------------+
|                  0 |
+--------------------+

Instead:

SELECT CASE WHEN ISNULL(NULL) 
THEN 'null found' 
ELSE 'null not found' 
END 
AS 'NULL';
+------------+
| NULL       |
+------------+
| null found |
+------------+

mysql> SELECT CASE WHEN ISNULL('derp')
THEN 'null found' 
ELSE 'null not found' 
END 
AS 'NULL';
+----------------+
| NULL           |
+----------------+
| null not found |
+----------------+

!!!!!!!!!!!!!!!!!!!!!!!!!

That works, but MySQL has IFNULL instead:

SELECT IFNULL(NULL, 'test');
+----------------------+
| IFNULL(NULL, 'test') |
+----------------------+
| test                 |
+----------------------+

mysql> SELECT IFNULL('derp', 'test');
+------------------------+
| IFNULL('derp', 'test') |
+------------------------+
| derp                   |
+------------------------+

!!!!!!!!!!!!!!!!!!!!!!!!!!

Use to find if column NULL, if so, can give different default value instead.

---------------------------------------------------

COALESCE
Returns the first non-null value from a list

Example:

SELECT COALESCE(NULL, NULL, 'derp', NULL, 'testing') AS SomeValue;
+-----------+
| SomeValue |
+-----------+
| derp      |
+-----------+

Can put all columns, put a default value at very end to use if everything NULL.

---------------------------------------------------

ISNULL					COALESCE

Limited to 2 values		Unlimited

faster					Slow

SQL Server -> ISNULL	Available in al DBMSs
Oracle -> NVL
MySQL -> IFNULL

---------------------------------------------------

Use Case:

*Handle the NULL before doing data aggregations.

All AGGR functions ignore null, unless COUNT(*).

Example:

SELECT Score FROM customers;
+-------+
| Score |
+-------+
|   350 |
|   900 |
|   750 |
|   500 |
|  NULL |
+-------+

SELECT COUNT(score) AS ScoreCount FROM customers;
+------------+
| ScoreCount |
+------------+
|          4 |
+------------+

SELECT COUNT(IFNULL(score, 1)) AS ScoreCount FROM customers;
+------------+
| ScoreCount |
+------------+
|          5 |
+------------+


*Handle the NULL before doing mathematical operations:

SELECT score, score + 1 AS UpdatedScore FROM customers;
+-------+--------------+
| score | UpdatedScore |
+-------+--------------+
|   350 |          351 |
|   900 |          901 |
|   750 |          751 |
|   500 |          501 |
|  NULL |         NULL |
+-------+--------------+

SELECT score, IFNULL(score, 0) + 1 AS UpdatedScore FROM customers;
+-------+--------------+
| score | UpdatedScore |
+-------+--------------+
|   350 |          351 |
|   900 |          901 |
|   750 |          751 |
|   500 |          501 |
|  NULL |            1 |
+-------+--------------+

SELECT score, score * 2 AS UpdatedScore FROM customers;
+-------+--------------+
| score | UpdatedScore |
+-------+--------------+
|   350 |          700 |
|   900 |         1800 |
|   750 |         1500 |
|   500 |         1000 |
|  NULL |         NULL |
+-------+--------------+

SELECT score, IFNULL(score, 1) * 1 AS UpdatedScore FROM customers;
+-------+--------------+
| score | UpdatedScore |
+-------+--------------+
|   350 |          350 |
|   900 |          900 |
|   750 |          750 |
|   500 |          500 |
|  NULL |            1 |
+-------+--------------+

Last name NULL:

SELECT CONCAT(firstname, ' ', lastname) AS FullName FROM customers;
+-----------------+
| FullName        |
+-----------------+
| Jossef Goldberg |
| Kevin Brown     |
| NULL            |
| Mark Schwarz    |
| Anna Adams      |
+-----------------+

SELECT CONCAT(firstname, ' ', COALESCE(lastname, '')) AS FullName FROM customers;
+-----------------+
| FullName        |
+-----------------+
| Jossef Goldberg |
| Kevin Brown     |
| Mary            |
| Mark Schwarz    |
| Anna Adams      |
+-----------------+

*Handle NULL before JOINing tables:

Need 2 keys to JOIN 2 tables, but some of the second keys are NULL.
Can't compare NULL using = operator used in JOIN condition ON.

a.type = b.type

Instead:

IFNULL(a.type, '') = IFNULL(b.type, '')

*Handle NULL before sorting the data:

NULL becomes first if sorting lowest to  highest:

SELECT firstname, lastname FROM customers ORDER BY lastname;
+-----------+----------+
| firstname | lastname |
+-----------+----------+
| Mary      | NULL     |
| Anna      | Adams    |
| Kevin     | Brown    |
| Jossef    | Goldberg |
| Mark      | Schwarz  |
+-----------+----------+

Method #1, replace with very low ranking last name:

SELECT firstname, lastname FROM customers 
ORDER BY IFNULL(lastname, 'ZZZZZZZZZZZZZZZ');
+-----------+----------+
| firstname | lastname |
+-----------+----------+
| Anna      | Adams    |
| Kevin     | Brown    |
| Jossef    | Goldberg |
| Mark      | Schwarz  |
| Mary      | NULL     |
+-----------+----------+

Not best method, use this instead:

SELECT firstname, lastname, 
CASE WHEN ISNULL(lastname) 
	THEN 1 
	ELSE 0 
END AS Flag 
FROM customers 
ORDER BY Flag, lastname;
+-----------+----------+------+
| firstname | lastname | Flag |
+-----------+----------+------+
| Anna      | Adams    |    0 |
| Kevin     | Brown    |    0 |
| Jossef    | Goldberg |    0 |
| Mark      | Schwarz  |    0 |
| Mary      | NULL     |    1 |
+-----------+----------+------+


---------------------------------------------------

NULLIF
Returns NULL if Column1/Value1 matches Column2/Value2
Else returns Column1/Value1 

Example:

SELECT NULLIF('derp', 'derp');
+------------------------+
| NULLIF('derp', 'derp') |
+------------------------+
| NULL                   |
+------------------------+

SELECT NULLIF('notderp', 'derp');
+---------------------------+
| NULLIF('notderp', 'derp') |
+---------------------------+
| notderp                   |
+---------------------------+

Use Case:

Compare Original_Price to Discount_Price,
if NULLIF returns NULL on this comparison, clearly there is an error somewhere.
(The 2 shouldn't match)

Prevent error of dividing by zero:

SELECT 5 / 0;
+-------+
| 5 / 0 |
+-------+
|  NULL |
+-------+
1 row in set, 1 warning (0.00 sec)

MySQL gives warning:

show warnings;
+---------+------+---------------+
| Level   | Code | Message       |
+---------+------+---------------+
| Warning | 1365 | Division by 0 |
+---------+------+---------------+

Use this instead:

SELECT 5 / NULLIF(0, 0);
+------------------+
| 5 / NULLIF(0, 0) |
+------------------+
|             NULL |
+------------------+

---------------------------------------------------

Check for NULLs:

IS NULL

Return TRUE if value is NULL
Else return FALSE

IS NOT NULL

Return TRUE if value is not NULL
Else return FALSE

Example:

SELECT 
	'IS NULL' AS FunctionName, 
	NULL IS NULL AS NullValue, 
	'derp' IS NULL AS DerpValue 
UNION ALL 
SELECT 
	'IS NOT NULL' AS FunctionName,
	NULL IS NOT NULL AS NullValue, 
	'derp' IS NOT NULL AS DerpValue;
+--------------+-----------+-----------+
| FunctionName | NullValue | DerpValue |
+--------------+-----------+-----------+
| IS NULL      |         1 |         0 |
| IS NOT NULL  |         0 |         1 |
+--------------+-----------+-----------+

Use Cases:

Searching for missing information, then can be followed up by filling in or 
fixing in some way.

SELECT * FROM customers WHERE score IS NULL;
+------------+-----------+----------+---------+-------+
| customerid | firstname | lastname | country | score |
+------------+-----------+----------+---------+-------+
|          5 | Anna      | Adams    | USA     |  NULL |
+------------+-----------+----------+---------+-------+

Find all customers that don't match names with employees

SELECT * FROM customers c 
LEFT JOIN employees e 
ON 
	c.firstname = e.firstname 
	AND 
	c.lastname = e.lastname 
WHERE e.firstname IS NULL AND e.lastname IS NULL;
+------------+-----------+----------+---------+-------+------------+-----------+----------+------------+-----------+--------+--------+-----------+
| customerid | firstname | lastname | country | score | employeeid | firstname | lastname | department | birthdate | gender | salary | managerid |
+------------+-----------+----------+---------+-------+------------+-----------+----------+------------+-----------+--------+--------+-----------+
|          1 | Jossef    | Goldberg | Germany |   350 |       NULL | NULL      | NULL     | NULL       | NULL      | NULL   |   NULL |      NULL |
|          3 | Mary      | NULL     | USA     |   750 |       NULL | NULL      | NULL     | NULL       | NULL      | NULL   |   NULL |      NULL |
|          4 | Mark      | Schwarz  | Germany |   500 |       NULL | NULL      | NULL     | NULL       | NULL      | NULL   |   NULL |      NULL |
|          5 | Anna      | Adams    | USA     |  NULL |       NULL | NULL      | NULL     | NULL       | NULL      | NULL   |   NULL |      NULL |
+------------+-----------+----------+---------+-------+------------+-----------+----------+------------+-----------+--------+--------+-----------+

Mary NULL should not be in there, does exist in the employees table, here:

SELECT * FROM customers c 
LEFT JOIN employees e 
ON 
	c.firstname = e.firstname 
	AND 
	IFNULL(c.lastname, '') = IFNULL(e.lastname, '') 
WHERE e.firstname IS NULL 
+------------+-----------+----------+---------+-------+------------+-----------+----------+------------+-----------+--------+--------+-----------+
| customerid | firstname | lastname | country | score | employeeid | firstname | lastname | department | birthdate | gender | salary | managerid |
+------------+-----------+----------+---------+-------+------------+-----------+----------+------------+-----------+--------+--------+-----------+
|          1 | Jossef    | Goldberg | Germany |   350 |       NULL | NULL      | NULL     | NULL       | NULL      | NULL   |   NULL |      NULL |
|          4 | Mark      | Schwarz  | Germany |   500 |       NULL | NULL      | NULL     | NULL       | NULL      | NULL   |   NULL |      NULL |
|          5 | Anna      | Adams    | USA     |  NULL |       NULL | NULL      | NULL     | NULL       | NULL      | NULL   |   NULL |      NULL |
+------------+-----------+----------+---------+-------+------------+-----------+----------+------------+-----------+--------+--------+-----------+

Fixed!

---------------------------------------------------

NULL vs. Empty String vs. Blank Space

NULL is nothing, don't know about it.

Empty string is just a string with zero characters.

Blank space has one or more space characters.
>= 1 looks the same at a glance!

Can use LENGTH to find number of whitespace chars in string.


					NULL				Empty String				Blank Space

Representation		NULL				''							' '

Meaning				Unknown				Known, Empty value			Known, Space value

Data Type			Special Marker		String(0)					String(1+)			

Storage				Very Minimal		Occupies Memory				Each Occupies Memory

Performance			Best				Fast						Slow

Comparison			IS NULL				= ''						= ' '

-------------------------------------------------------

Data Policies:

Data input can often involve data with very different setups or corruption,
need to know how to work with all cases, how to filter, how to fix.
All that given the data policy for whatever organization you are working with.

Should always avoid spaces and just use empty strings or NULLs instead.

#1 Data Policy

Use NULLS and Empty strings.

#2 Data Policy

Only use NULLS and avoid using empty strings and blank spaces.

Policy #2 easier to understand and deal with.

#3 Data Policy

Use the default value 'unknown' and avoid using nulls, empty string, and blank spaces:

All 3 as an example:

WITH orders AS (
	SELECT 1 Id, 'A' Category 
	UNION 
	SELECT 2, NULL 
	UNION 
	SELECT 3, '' 
	UNION 
	SELECT 4, '     '
) 
SELECT 
	*, 
	LENGTH(Category) CategoryLen, 
	LENGTH(TRIM(Category)) Policy1, 
	NULLIF(TRIM(Category), '') Policy2,
	COALESCE(NULLIF(TRIM(Category), '') , 'unknown') Policy3
FROM orders;
+----+----------+-------------+---------+---------+---------+
| Id | Category | CategoryLen | Policy1 | Policy2 | Policy3 |
+----+----------+-------------+---------+---------+---------+
|  1 | A        |           1 |       1 | A       | A       |
|  2 | NULL     |        NULL |    NULL | NULL    | unknown |
|  3 |          |           0 |       0 | NULL    | unknown |
|  4 |          |           5 |       0 | NULL    | unknown |
+----+----------+-------------+---------+---------+---------+

When working with data on own, use Policy #2,
But use Policy #3 for presentation.

Summary:

NULLs are special markers in SQL that mean 'missing value'
Using NULLs can optimize storage and performance.

NULL functions can replace values or check values if they are NULL.

Need to handle NULLs before data aggregation, math ops, joining tables, sorting data

