[CTE: Common Table Expression]

AKA Temporary named result set (virtual table) that can be used multiple 
times within your query to simplify and organize complex query.

Executes CTE Query first, get intermediate, temporary result table.
Main query can retrieve data from temporary result table any time.
Once main query ends, SQL destroys temporary table.

Outside query cannot access this CTE table, dedicated only to inside main query.

CTE written top to bottom, while subquery is written bottom to top.

How are they really different?

Subquery result can only be used once in one place, 
while CTE can be used as many times as needed, in any part of the main query.

-------------------------------------------------

When to use?

If repeating the same steps more than once, better to use a CTE that can be pulled from
as many times as needed. Using subqueries instead would create redundancy, CTE removes the redundancy.

If many complex tasks, can break them up into pieces to work with one at a time (Divide & Conquer), 
and can be used again in other queries. (Readability, Modularity, Reusability)

CTE table also gets stored in the cache making data retrieval from it very efficient.

Cannot use ORDER BY clause in CTE! (But can in main query)

------------------

Best practices:

People tend to overuse the CTE.

Try to not add a CTE for each new calculation or each new column. It ends up being a massive mess
that is hard to understand. Might also end up having bad performance.

Better to rethink and refactor multiple CTEs into one.

Probably don't use more than 5 CTEs in one query.

------------------

Example:

WITH CTE_Example AS (				<- CTE
	SELECT 
		orderid, 
		orderdate FROM orders
	) 
	SELECT * 						<- Main query
	FROM CTE_Example 
	ORDER BY orderdate DESC;
+---------+------------+
| orderid | orderdate  |
+---------+------------+
|      10 | 2025-03-15 |
|       9 | 2025-03-10 |
|       8 | 2025-02-18 |
|       7 | 2025-02-15 |
|       6 | 2025-02-05 |
|       5 | 2025-02-01 |
|       4 | 2025-01-20 |
|       3 | 2025-01-10 |
|       2 | 2025-01-05 |
|       1 | 2025-01-01 |
+---------+------------+


-------------------------------------------------

Non-Recursive CTE:

CTE Executed only once without any repetition.

------------------------

Standalone CTE

Defined and Used independently.

Runs independently as it's self-contained and doesn't rely on other CTEs or queries.

CTE queries DB, gets intermediate result. Then, main query, which is dependent on the 
intermediate result, uses it to get the final result.

Examples:

WITH CTE_TotalSales AS (
	SELECT 
		customerid, 
		SUM(sales) AS TotalSales 
	FROM orders 
	GROUP BY customerid
) 
SELECT 
	c.customerid, 
	firstname, 
	lastname, 
	cts.TotalSales 
FROM customers c 
LEFT JOIN CTE_TotalSales cts 
ON cts.customerid = c.customerid;
+------------+-----------+----------+------------+
| customerid | firstname | lastname | TotalSales |
+------------+-----------+----------+------------+
|          1 | Jossef    | Goldberg |        110 |
|          2 | Kevin     | Brown    |         55 |
|          3 | Mary      | NULL     |        125 |
|          4 | Mark      | Schwarz  |         90 |
|          5 | Anna      | Adams    |       NULL |
+------------+-----------+----------+------------+

--------------

Multiple Standalone CTE:

WITH CTE_TotalSales AS (
	SELECT 
		customerid, 
		SUM(sales) AS TotalSales 
	FROM orders 
	GROUP BY customerid
), 
CTE_LastOrder AS (
	SELECT 
		customerid, 
		MAX(orderdate) AS LastOrder 
	FROM orders 
	GROUP BY customerid
) 
SELECT 
	c.customerid, 
	firstname, 
	lastname, 
	cts.TotalSales, 
	clo.LastOrder 
FROM customers c 
LEFT JOIN CTE_TotalSales cts 
ON cts.customerid = c.customerid 
LEFT JOIN CTE_LastOrder clo 
ON clo.customerid = cts.customerid;
+------------+-----------+----------+------------+------------+
| customerid | firstname | lastname | TotalSales | LastOrder  |
+------------+-----------+----------+------------+------------+
|          1 | Jossef    | Goldberg |        110 | 2025-02-15 |
|          2 | Kevin     | Brown    |         55 | 2025-03-10 |
|          3 | Mary      | NULL     |        125 | 2025-03-15 |
|          4 | Mark      | Schwarz  |         90 | 2025-02-18 |
|          5 | Anna      | Adams    |       NULL | NULL       |
+------------+-----------+----------+------------+------------+

------------------------

Nested CTE

CTE inside another CTE. A nested CTE uses the result of another CTE, so it can't run independently.

DB <-> #1 CTE -> Intermediate 1 <-> #2 CTE -> Intermediate 2 (final) <-> Main Query -> Final Result

^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Standalone CTE	     	Nested CTE

Example:

WITH CTE_TotalSales AS (
	SELECT 
		customerid, 
		SUM(sales) AS TotalSales 
	FROM orders 
	GROUP BY customerid
), 
CTE_LastOrder AS (
	SELECT 
		customerid, 
		MAX(orderdate) AS LastOrder 
	FROM orders 
	GROUP BY customerid
), 
CTE_CustomerRank AS (
	SELECT 
		customerid, 
		TotalSales, 
		RANK() OVER (ORDER BY TotalSales DESC) AS CustomerRank 
	FROM CTE_TotalSales
) 
SELECT 
	c.customerid, 
	firstname, 
	lastname, 
	cts.TotalSales, 
	clo.LastOrder, 
	ccr.CustomerRank 
FROM customers c 
LEFT JOIN CTE_TotalSales cts 
ON cts.customerid = c.customerid 
LEFT JOIN CTE_LastOrder clo 
ON clo.customerid = c.customerid 
LEFT JOIN CTE_CustomerRank ccr 
ON ccr.customerid = c.customerid;
+------------+-----------+----------+------------+------------+--------------+
| customerid | firstname | lastname | TotalSales | LastOrder  | CustomerRank |
+------------+-----------+----------+------------+------------+--------------+
|          1 | Jossef    | Goldberg |        110 | 2025-02-15 |            2 |
|          2 | Kevin     | Brown    |         55 | 2025-03-10 |            4 |
|          3 | Mary      | NULL     |        125 | 2025-03-15 |            1 |
|          4 | Mark      | Schwarz  |         90 | 2025-02-18 |            3 |
|          5 | Anna      | Adams    |       NULL | NULL       |         NULL |
+------------+-----------+----------+------------+------------+--------------+

Another:

WITH CTE_TotalSales AS (
	SELECT 
		customerid, 
		SUM(sales) AS TotalSales 
	FROM orders 
	GROUP BY customerid
), 
CTE_LastOrder AS (
	SELECT 
		customerid, 
		MAX(orderdate) AS LastOrder 
	FROM orders 
	GROUP BY customerid
), 
CTE_CustomerRank AS (
	SELECT 
		customerid, 
		TotalSales, 
		RANK() OVER (ORDER BY TotalSales DESC) AS CustomerRank 
	FROM CTE_TotalSales
), 
CTE_CustomerSegments AS (
	SELECT 
		customerid, 
		CASE 
			WHEN TotalSales > 100 THEN 'High' 
			WHEN TotalSales > 50 THEN 'Medium' 
			ELSE 'Low' 
		END AS CustomerSegments 
	FROM CTE_TotalSales
) SELECT 
	c.customerid, 
	firstname, 
	lastname, 
	cts.TotalSales, 
	clo.LastOrder, 
	ccr.CustomerRank, 
	ccs.CustomerSegments 
FROM customers c 
LEFT JOIN CTE_TotalSales cts 
ON cts.customerid = c.customerid 
LEFT JOIN CTE_LastOrder clo 
ON clo.customerid = c.customerid 
LEFT JOIN CTE_CustomerRank ccr 
ON ccr.customerid = c.customerid 
LEFT JOIN CTE_CustomerSegments ccs 
ON ccs.customerid = c.customerid;
+------------+-----------+----------+------------+------------+--------------+------------------+
| customerid | firstname | lastname | TotalSales | LastOrder  | CustomerRank | CustomerSegments |
+------------+-----------+----------+------------+------------+--------------+------------------+
|          1 | Jossef    | Goldberg |        110 | 2025-02-15 |            2 | High             |
|          2 | Kevin     | Brown    |         55 | 2025-03-10 |            4 | Medium           |
|          3 | Mary      | NULL     |        125 | 2025-03-15 |            1 | High             |
|          4 | Mark      | Schwarz  |         90 | 2025-02-18 |            3 | Medium           |
|          5 | Anna      | Adams    |       NULL | NULL       |         NULL | NULL             |
+------------+-----------+----------+------------+------------+--------------+------------------+

-------------------------------------------------

Recursive CTE

Self-referencing query that repeatedly processes data until a specific condition is met.

Used to travel through hierarchical structures.

Syntax:

WITH CTE_Name AS (
	SELECT ...				<- Anchor query
	FROM ...
	WHERE ...

	UNION ALL
	
	SELECT ...				<- Recursive query
	FROM CTE_Name
	WHERE (Break Condition)
)

SELECT ...					<- Main query
FROM CTE_Name
WHERE ...

Example:

-- Generate a sequence of numbers from 1 to 20:

WITH RECURSIVE Series AS (
	SELECT 1 AS MyNumber 
	UNION ALL 
	SELECT MyNumber + 1 
	FROM Series 
	WHERE MyNumber < 20
) 
SELECT * FROM Series;
+----------+
| MyNumber |
+----------+
|        1 |
|        2 |
|        3 |
|        4 |
|        5 |
|        6 |
|        7 |
|        8 |
|        9 |
|       10 |
|       11 |
|       12 |
|       13 |
|       14 |
|       15 |
|       16 |
|       17 |
|       18 |
|       19 |
|       20 |
+----------+

----------------------

--  Show the employee hierarchy by displaying each employees level within the 
organization:

WITH RECURSIVE CTE_EmployeeTree AS (
	SELECT 
		employeeid, 
		firstname, 
		managerid, 
		1 AS Level 
	FROM employees 
	WHERE managerid IS NULL 
	UNION ALL 
	SELECT 
		e.employeeid, 
		e.firstname, 
		e.managerid, 
		Level + 1 
	FROM employees AS e 
	INNER JOIN CTE_EmployeeTree cet 
	ON e.managerid = cet.employeeid
) 
SELECT * FROM CTE_EmployeeTree;
+------------+-----------+-----------+-------+
| employeeid | firstname | managerid | Level |
+------------+-----------+-----------+-------+
|          1 | Frank     |      NULL |     1 |
|          2 | Kevin     |         1 |     2 |
|          3 | Mary      |         1 |     2 |
|          4 | Michael   |         2 |     3 |
|          5 | Carol     |         3 |     3 |
+------------+-----------+-----------+-------+

Levels:

				1
			 / 	   \
			/		\	
			2		2
			|		|
			3		3

-------------------------------------------------


