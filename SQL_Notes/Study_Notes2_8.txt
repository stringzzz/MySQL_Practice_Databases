[Window Functions]

AKA Analytical Functions

-------------------------------------------

[Basics]

Window Functions: Perform calculations (e.g. aggregation) on a specific subset of data,
without losing the level of details of rows.

Columns 'product' has 'Caps' and 'Gloves'. 4 rows, GROUP BY product yields
2 rows with total sales for 'Caps' and 'Gloves'.

Window function gets total sales, but keeps same number of rows showing all the info.

Doesn't lose level of details, 'Row-Level Calculation'.

WINDOW functions are for more advanced data tasks.

-------------------------------------------

WINDOW Functions:

Example:

SELECT orderid, orderdate, productid, sales, 
SUM(sales) OVER(PARTITION BY productid) AS TotalSalesByProducts 
FROM orders;
+---------+------------+-----------+-------+----------------------+
| orderid | orderdate  | productid | sales | TotalSalesByProducts |
+---------+------------+-----------+-------+----------------------+
|       1 | 2025-01-01 |       101 |    10 |                  140 |
|       3 | 2025-01-10 |       101 |    20 |                  140 |
|       8 | 2025-02-18 |       101 |    90 |                  140 |
|       9 | 2025-03-10 |       101 |    20 |                  140 |
|       2 | 2025-01-05 |       102 |    15 |                  105 |
|       7 | 2025-02-15 |       102 |    30 |                  105 |
|      10 | 2025-03-15 |       102 |    60 |                  105 |
|       5 | 2025-02-01 |       104 |    25 |                   75 |
|       6 | 2025-02-05 |       104 |    50 |                   75 |
|       4 | 2025-01-20 |       105 |    60 |                   60 |
+---------+------------+-----------+-------+----------------------+


Syntax:

WINDOW_FUNCTION() OVER(Partition_Clause Order_Clause Frame_Clause)

Example:

AVG(Column1) OVER (PARTITION BY Column2 ORDER BY Column3 ROWS UNBOUNDED PRECEDING)

Perform calculations within a window.

The Window_Function is the calculation.

Column1 can be empty, column, can be number (in certain functions), some with multiple arguments,
or whole conditional logic.

OVER specifies that it is a Window Function.

PARTITION BY Divides the result set into partitions (Windows).

Empty? Calculation is done on entire Dataset.
Column? Divides into Windows.

PARTITION BY always optional.

Examples:

SELECT MONTH(orderdate) AS Month, sales, orderstatus, 
	SUM(sales) OVER(PARTITION BY MONTH(orderdate)) AS SalesPerMonth, 
	SUM(sales) OVER () AS TotalSales, 
	SUM(sales) OVER (PARTITION BY MONTH(orderdate), orderstatus) AS SalesPerMonthAndStatus 
FROM orders;
+-------+-------+-------------+---------------+------------+------------------------+
| Month | sales | orderstatus | SalesPerMonth | TotalSales | SalesPerMonthAndStatus |
+-------+-------+-------------+---------------+------------+------------------------+
|     1 |    10 | Delivered   |           105 |        380 |                     30 |
|     1 |    20 | Delivered   |           105 |        380 |                     30 |
|     1 |    15 | Shipped     |           105 |        380 |                     75 |
|     1 |    60 | Shipped     |           105 |        380 |                     75 |
|     2 |    25 | Delivered   |           195 |        380 |                    105 |
|     2 |    50 | Delivered   |           195 |        380 |                    105 |
|     2 |    30 | Delivered   |           195 |        380 |                    105 |
|     2 |    90 | Shipped     |           195 |        380 |                     90 |
|     3 |    20 | Shipped     |            80 |        380 |                     80 |
|     3 |    60 | Shipped     |            80 |        380 |                     80 |
+-------+-------+-------------+---------------+------------+------------------------+

------------------------------------------------------------------

Window Functions: Allows aggregation of data at different granularities within
the same query.

ORDER BY sorts data within a Window. Optional in Aggregate, 
but required in Rank and Value functions.

SELECT sales, 
	SUM(sales) OVER(PARTITION BY MONTH(orderdate) ORDER BY sales DESC) AS SalesPerMonth 
FROM orders;
+-------+---------------+
| sales | SalesPerMonth |
+-------+---------------+
|    60 |            60 |
|    20 |            80 |
|    15 |            95 |
|    10 |           105 |
|    90 |            90 |
|    50 |           140 |
|    30 |           170 |
|    25 |           195 |
|    60 |            60 |
|    20 |            80 |
+-------+---------------+

RANK:

SELECT orderid, orderdate, sales, 
	RANK() OVER (ORDER BY sales DESC) AS RankSales 
FROM orders;
+---------+------------+-------+-----------+
| orderid | orderdate  | sales | RankSales |
+---------+------------+-------+-----------+
|       8 | 2025-02-18 |    90 |         1 |
|       4 | 2025-01-20 |    60 |         2 |
|      10 | 2025-03-15 |    60 |         2 |
|       6 | 2025-02-05 |    50 |         4 |
|       7 | 2025-02-15 |    30 |         5 |
|       5 | 2025-02-01 |    25 |         6 |
|       3 | 2025-01-10 |    20 |         7 |
|       9 | 2025-03-10 |    20 |         7 |
|       2 | 2025-01-05 |    15 |         9 |
|       1 | 2025-01-01 |    10 |        10 |
+---------+------------+-------+-----------+

------------------------------------------------------

Window Frame (Frame Clause):

Defines a subset of rows within each window that is relevant for the calculation.

AVG(sales) OVER (
	PARTITION BY Category
	ORDER BY orderdate
	ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
)

Must have ORDER BY to use Frame Clause.

ROWS: Frame Types: ROWS, RANGE

CURRENT ROW: Frame Boundary (Lower Value): CURRENT ROW, N PRECEDING, UNBOUNDED PRECEDING

UNBOUNDED FOLLOWING: Frame Boundary (Higher Value): CURRENT ROW, N FOLLOWING, UNBOUNDED FOLLOWING

SELECT sales, 
SUM(sales) OVER (ORDER BY MONTH(orderdate)) AS SalesTotal 
FROM orders;
+-------+------------+
| sales | SalesTotal |
+-------+------------+
|    10 |        105 |
|    15 |        105 |
|    20 |        105 |
|    60 |        105 |
|    25 |        300 |
|    50 |        300 |
|    30 |        300 |
|    90 |        300 |
|    20 |        380 |
|    60 |        380 |
+-------+------------+
10 rows in set (0.00 sec)

SELECT sales, 
SUM(sales) OVER (
	ORDER BY MONTH(orderdate) 
	ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING
) AS SalesTotal 
FROM orders;
+-------+------------+
| sales | SalesTotal |
+-------+------------+
|    10 |         45 | <- Sum of current row and following 2 rows: 10 + 15 + 20 = 45
|    15 |         95 | <- Sum of current row and following 2 rows: 15 + 20 + 60 = 95
|    20 |        105 | <- etc.
|    60 |        135 |
|    25 |        105 |
|    50 |        170 |
|    30 |        140 |
|    90 |        170 |
|    20 |         80 | <- Sum of current row and following 2 rows: 20 + 60 + 0(None) = 80
|    60 |         60 | <- Sum of current row and following 2 rows: 60 + 0 + 0 = 60
+-------+------------+

Slides down the rows calculating as it goes.

UNBOUNDED FOLLOWING is all the rest (Less and less rows as it slides down)

1 PRECEDING AND CURRENT ROW:

SELECT sales, 
SUM(sales) OVER (
	ORDER BY MONTH(orderdate) 
	ROWS BETWEEN 1 PRECEDING AND CURRENT ROW
) AS SalesTotal 
FROM orders;
+-------+------------+
| sales | SalesTotal |
+-------+------------+
|    10 |         10 | <- 0 + 10 = 10
|    15 |         25 | <- 10 + 15 = 25
|    20 |         35 | <- etc.
|    60 |         80 |
|    25 |         85 |
|    50 |         75 |
|    30 |         80 |
|    90 |        120 |
|    20 |        110 |
|    60 |         80 | <- 20 + 60 = 80
+-------+------------+

UNBOUNDED PRECEDING AND CURRENT ROW

Current row and all before it, so more rows as it moves on.

1 PRECEDING AND ! FOLLOWING

1 row before and after current row.

UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING

All rows regardless of current row.

Compact Frame:

For only PRECEDING, the CURRENT ROW can be skipped:

Normal Form: ROWS BETWEEN CURRENT ROW AND 2 PRECEDING
Short Form: ROWS 2 PRECEDING

Without specifying a Frame using ORDER BY, SQL uses default Frame:
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

No Frame if not using ORDER BY.

----------------------------------------

4x Rules (Limitiations):

Rule #1. Window functions can be used only in SELECT and ORDER BY clauses.

Example:

SELECT sales, 
SUM(sales) OVER (ORDER BY MONTH(orderdate)) AS SalesTotal 
FROM orders 
ORDER BY SUM(sales) OVER (ORDER BY MONTH(orderdate)) DESC;
+-------+------------+
| sales | SalesTotal |
+-------+------------+
|    20 |        380 |
|    60 |        380 |
|    25 |        300 |
|    50 |        300 |
|    30 |        300 |
|    90 |        300 |
|    10 |        105 |
|    15 |        105 |
|    20 |        105 |
|    60 |        105 |
+-------+------------+

If needed to use same exact Window in both, just use the alias:

SELECT sales, 
SUM(sales) OVER (ORDER BY MONTH(orderdate)) AS SalesTotal 
FROM orders 
ORDER BY SalesTotal DESC;
+-------+------------+
| sales | SalesTotal |
+-------+------------+
|    20 |        380 |
|    60 |        380 |
|    25 |        300 |
|    50 |        300 |
|    30 |        300 |
|    90 |        300 |
|    10 |        105 |
|    15 |        105 |
|    20 |        105 |
|    60 |        105 |
+-------+------------+

Window functions cannot be used to filter data.
(No WHERE Clause or GROUP BY)

-------------

Rule #2. Window functions cannot be nested.

-------------

Rule #3. SQL executes WINDOW function after the WHERE Clause.
(Filters first, then executes Window function)

-------------

Rule #4. Window Function can be used together with GROUP BY in the same query, 
ONLY if the same columns are used.

Example:

SELECT customerid, 
SUM(sales) AS TotalSales, RANK() OVER (
	ORDER BY SUM(sales) DESC
) AS RankCustomers 
FROM orders 
GROUP BY customerid;
+------------+------------+---------------+
| customerid | TotalSales | RankCustomers |
+------------+------------+---------------+
|          3 |        125 |             1 |
|          1 |        110 |             2 |
|          4 |         90 |             3 |
|          2 |         55 |             4 |
+------------+------------+---------------+

First build by GROUP BY, then define and build Window Function.

-----------------------------

Summary:

Performs calculations on a subset of data without losing details.

Window functions are more powerful and dynamic in comparison to the GROUP BY.

Data analysis can be more advanced.

Can use both at once if same columns are used.

Rule #1. Window functions can be used only in SELECT and ORDER BY clauses.

Rule #2. Window functions cannot be nested.

Rule #3. SQL executes WINDOW function after the WHERE Clause.
(Filters first, then executes Window function)

Rule #4. Window Function can be used together with GROUP BY in the same query, 
ONLY if the same columns are used.

-----------------------------
-----------------------------

Aggregate:

COUNT for any data type, Numeric only with SUM, AVG, MIN, and MAX.

For all Aggregate: Partition, Order, and Frame clauses are optional.

---------------------------------------------------------------------

COUNT

Example:

SELECT MONTH(orderdate), sales, COUNT(*) OVER () AS total_orders FROM orders;
+------------------+-------+--------------+
| MONTH(orderdate) | sales | total_orders |
+------------------+-------+--------------+
|                1 |    10 |           10 |
|                1 |    15 |           10 |
|                1 |    20 |           10 |
|                1 |    60 |           10 |
|                2 |    25 |           10 |
|                2 |    50 |           10 |
|                2 |    30 |           10 |
|                2 |    90 |           10 |
|                3 |    20 |           10 |
|                3 |    60 |           10 |
+------------------+-------+--------------+

SELECT 
	MONTH(orderdate), 
	sales, 
	customerid, 
	COUNT(*) OVER () AS total_orders, 
	COUNT(*) OVER (PARTITION BY customerid) AS OrdersByCustomers 
FROM orders;
+------------------+-------+------------+--------------+-------------------+
| MONTH(orderdate) | sales | customerid | total_orders | OrdersByCustomers |
+------------------+-------+------------+--------------+-------------------+
|                1 |    20 |          1 |           10 |                 3 |
|                1 |    60 |          1 |           10 |                 3 |
|                2 |    30 |          1 |           10 |                 3 |
|                1 |    10 |          2 |           10 |                 3 |
|                2 |    25 |          2 |           10 |                 3 |
|                3 |    20 |          2 |           10 |                 3 |
|                1 |    15 |          3 |           10 |                 3 |
|                2 |    50 |          3 |           10 |                 3 |
|                3 |    60 |          3 |           10 |                 3 |
|                2 |    90 |          4 |           10 |                 1 |
+------------------+-------+------------+--------------+-------------------+

SELECT 
	*, 
	COUNT(*) OVER () AS TotalCustomers, 
	COUNT(score) OVER () AS TotalScores 
FROM customers;
+------------+-----------+----------+---------+-------+----------------+-------------+
| customerid | firstname | lastname | country | score | TotalCustomers | TotalScores |
+------------+-----------+----------+---------+-------+----------------+-------------+
|          1 | Jossef    | Goldberg | Germany |   350 |              5 |           4 |
|          2 | Kevin     | Brown    | USA     |   900 |              5 |           4 |
|          3 | Mary      | NULL     | USA     |   750 |              5 |           4 |
|          4 | Mark      | Schwarz  | Germany |   500 |              5 |           4 |
|          5 | Anna      | Adams    | USA     |  NULL |              5 |           4 |
+------------+-----------+----------+---------+-------+----------------+-------------+

*Duplicates can lead to inaccuracies in data:

Duplicate primary keys can be a problem.

To check:

SELECT 
	orderid, 
	COUNT(*) OVER (PARTITION BY orderid) AS CheckPrimaryKey 
FROM orders;
+---------+-----------------+
| orderid | CheckPrimaryKey |
+---------+-----------------+
|       1 |               1 |
|       2 |               1 |
|       3 |               1 |
|       4 |               1 |
|       5 |               1 |
|       6 |               1 |
|       7 |               1 |
|       8 |               1 |
|       9 |               1 |
|      10 |               1 |
+---------+-----------------+

Here is where there is a problem:

SELECT 
	orderid, 
	COUNT(*) OVER (PARTITION BY orderid) AS CheckPrimaryKey 
FROM orders_archive;
+---------+-----------------+
| orderid | CheckPrimaryKey |
+---------+-----------------+
|       1 |               1 |
|       2 |               1 |
|       3 |               1 |
|       4 |               2 |
|       4 |               2 |
|       5 |               1 |
|       6 |               3 |
|       6 |               3 |
|       6 |               3 |
|       7 |               1 |
+---------+-----------------+

Duplicates!

Find each duplicate exactly:

WITH CheckPrimaryKey AS (SELECT 
	orderid, 
	COUNT(*) OVER (PARTITION BY orderid) AS CheckPrimaryKey 
FROM orders_archive)
SELECT * FROM CheckPrimaryKey
WHERE CheckPrimaryKey > 1;
+---------+-----------------+
| orderid | CheckPrimaryKey |
+---------+-----------------+
|       4 |               2 |
|       4 |               2 |
|       6 |               3 |
|       6 |               3 |
|       6 |               3 |
+---------+-----------------+

Use Cases:

#1. Overall analysis
#2. Category analysis
#3. Quality Checks: Identify NULLs
#4. Quality Checks: Identify Duplicates

-----------------------------

SUM

Example:

SELECT 
	MONTH(orderdate), 
	sales, 
	SUM(sales) OVER (PARTITION BY MONTH(orderdate)) AS total_sales 
FROM orders;
+------------------+-------+-------------+
| MONTH(orderdate) | sales | total_sales |
+------------------+-------+-------------+
|                1 |    10 |         105 |
|                1 |    15 |         105 |
|                1 |    20 |         105 |
|                1 |    60 |         105 |
|                2 |    25 |         195 |
|                2 |    50 |         195 |
|                2 |    30 |         195 |
|                2 |    90 |         195 |
|                3 |    20 |          80 |
|                3 |    60 |          80 |
+------------------+-------+-------------+

SELECT 
	orderid, 
	orderdate, 
	sales, 
	productid, 
	SUM(sales) OVER (PARTITION BY productid) AS SalesByProduct 
FROM orders;
+---------+------------+-------+-----------+----------------+
| orderid | orderdate  | sales | productid | SalesByProduct |
+---------+------------+-------+-----------+----------------+
|       1 | 2025-01-01 |    10 |       101 |            140 |
|       3 | 2025-01-10 |    20 |       101 |            140 |
|       8 | 2025-02-18 |    90 |       101 |            140 |
|       9 | 2025-03-10 |    20 |       101 |            140 |
|       2 | 2025-01-05 |    15 |       102 |            105 |
|       7 | 2025-02-15 |    30 |       102 |            105 |
|      10 | 2025-03-15 |    60 |       102 |            105 |
|       5 | 2025-02-01 |    25 |       104 |             75 |
|       6 | 2025-02-05 |    50 |       104 |             75 |
|       4 | 2025-01-20 |    60 |       105 |             60 |
+---------+------------+-------+-----------+----------------+

------------

Comparison Use Cases
	Compare the current value and aggregated value of window functions

--------------------------------------------------------

Part-to-Whole analysis
	Compare current sales to total sales

Example:

SELECT 
	orderid, 
	productid, 
	sales, 
	SUM(sales) OVER () AS TotalSales, 
	CONCAT(
		CAST(
			CAST(sales AS float) / SUM(sales) OVER () * 100 AS DECIMAL(10, 3)
		), '%'
	) AS PercentageOfTotal 
FROM orders;
+---------+-----------+-------+------------+-------------------+
| orderid | productid | sales | TotalSales | PercentageOfTotal |
+---------+-----------+-------+------------+-------------------+
|       1 |       101 |    10 |        380 | 2.632%            |
|       2 |       102 |    15 |        380 | 3.947%            |
|       3 |       101 |    20 |        380 | 5.263%            |
|       4 |       105 |    60 |        380 | 15.789%           |
|       5 |       104 |    25 |        380 | 6.579%            |
|       6 |       104 |    50 |        380 | 13.158%           |
|       7 |       102 |    30 |        380 | 7.895%            |
|       8 |       101 |    90 |        380 | 23.684%           |
|       9 |       101 |    20 |        380 | 5.263%            |
|      10 |       102 |    60 |        380 | 15.789%           |
+---------+-----------+-------+------------+-------------------+


--------------------------------------------------------

Compare to Average analysis
	Help to evaluate whether a value is > or < the Average

Example:

SELECT 
	orderid, 
	productid, 
	sales, 
	AVG(sales) OVER () AS AverageSales 
FROM orders;
+---------+-----------+-------+--------------+
| orderid | productid | sales | AverageSales |
+---------+-----------+-------+--------------+
|       1 |       101 |    10 |      38.0000 |
|       2 |       102 |    15 |      38.0000 |
|       3 |       101 |    20 |      38.0000 |
|       4 |       105 |    60 |      38.0000 |
|       5 |       104 |    25 |      38.0000 |
|       6 |       104 |    50 |      38.0000 |
|       7 |       102 |    30 |      38.0000 |
|       8 |       101 |    90 |      38.0000 |
|       9 |       101 |    20 |      38.0000 |
|      10 |       102 |    60 |      38.0000 |
+---------+-----------+-------+--------------+


--------------------------------------------------------

-----------------------------

AVG

Example:

SELECT 
	orderid, 
	productid, 
	sales, 
	AVG(sales) OVER (PARTITION BY productid) AS AverageSales 
FROM orders;
+---------+-----------+-------+--------------+
| orderid | productid | sales | AverageSales |
+---------+-----------+-------+--------------+
|       1 |       101 |    10 |      35.0000 |
|       3 |       101 |    20 |      35.0000 |
|       8 |       101 |    90 |      35.0000 |
|       9 |       101 |    20 |      35.0000 |
|       2 |       102 |    15 |      35.0000 |
|       7 |       102 |    30 |      35.0000 |
|      10 |       102 |    60 |      35.0000 |
|       5 |       104 |    25 |      37.5000 |
|       6 |       104 |    50 |      37.5000 |
|       4 |       105 |    60 |      60.0000 |
+---------+-----------+-------+--------------+

SELECT 
	orderid, 
	orderdate, 
	productid, 
	sales, 
	AVG(sales) OVER () AS AverageSales, 
	AVG(sales) OVER (PARTITION BY productid) AS AveragePerProduct 
FROM orders;
+---------+------------+-----------+-------+--------------+-------------------+
| orderid | orderdate  | productid | sales | AverageSales | AveragePerProduct |
+---------+------------+-----------+-------+--------------+-------------------+
|       1 | 2025-01-01 |       101 |    10 |      38.0000 |           35.0000 |
|       3 | 2025-01-10 |       101 |    20 |      38.0000 |           35.0000 |
|       8 | 2025-02-18 |       101 |    90 |      38.0000 |           35.0000 |
|       9 | 2025-03-10 |       101 |    20 |      38.0000 |           35.0000 |
|       2 | 2025-01-05 |       102 |    15 |      38.0000 |           35.0000 |
|       7 | 2025-02-15 |       102 |    30 |      38.0000 |           35.0000 |
|      10 | 2025-03-15 |       102 |    60 |      38.0000 |           35.0000 |
|       5 | 2025-02-01 |       104 |    25 |      38.0000 |           37.5000 |
|       6 | 2025-02-05 |       104 |    50 |      38.0000 |           37.5000 |
|       4 | 2025-01-20 |       105 |    60 |      38.0000 |           60.0000 |
+---------+------------+-----------+-------+--------------+-------------------+

SELECT 
	orderid, 
	orderdate, 
	productid, 
	sales, 
	ROUND(AVG(sales) OVER ()) AS AverageSales, 
	ROUND(AVG(sales) OVER (PARTITION BY productid)) AS AveragePerProduct 
FROM orders;
+---------+------------+-----------+-------+--------------+-------------------+
| orderid | orderdate  | productid | sales | AverageSales | AveragePerProduct |
+---------+------------+-----------+-------+--------------+-------------------+
|       1 | 2025-01-01 |       101 |    10 |           38 |                35 |
|       3 | 2025-01-10 |       101 |    20 |           38 |                35 |
|       8 | 2025-02-18 |       101 |    90 |           38 |                35 |
|       9 | 2025-03-10 |       101 |    20 |           38 |                35 |
|       2 | 2025-01-05 |       102 |    15 |           38 |                35 |
|       7 | 2025-02-15 |       102 |    30 |           38 |                35 |
|      10 | 2025-03-15 |       102 |    60 |           38 |                35 |
|       5 | 2025-02-01 |       104 |    25 |           38 |                38 |
|       6 | 2025-02-05 |       104 |    50 |           38 |                38 |
|       4 | 2025-01-20 |       105 |    60 |           38 |                60 |
+---------+------------+-----------+-------+--------------+-------------------+

-----------------------------

Average Score without NULL:

SELECT 
	customerid, 
	lastname, 
	score, 
	COALESCE(score, 0) AS CustomerScore, 
	ROUND(AVG(score) OVER ()) AS AverageScore, 
	ROUND(AVG(COALESCE(score, 0)) OVER ()) AS AverageScoreNoNULL 
FROM customers;
+------------+----------+-------+---------------+--------------+--------------------+
| customerid | lastname | score | CustomerScore | AverageScore | AverageScoreNoNULL |
+------------+----------+-------+---------------+--------------+--------------------+
|          1 | Goldberg |   350 |           350 |          625 |                500 |
|          2 | Brown    |   900 |           900 |          625 |                500 |
|          3 | NULL     |   750 |           750 |          625 |                500 |
|          4 | Schwarz  |   500 |           500 |          625 |                500 |
|          5 | Adams    |  NULL |             0 |          625 |                500 |
+------------+----------+-------+---------------+--------------+--------------------+

-----------------------------

Find all orders where sales are higher than the average sales across all orders:

WITH AverageSales AS (
	SELECT 
		orderid, 
		productid, 
		sales, 
		AVG(COALESCE(sales, 0)) OVER () AS AverageSales 
	FROM orders
) SELECT * 
FROM AverageSales 
WHERE sales > AverageSales;
+---------+-----------+-------+--------------+
| orderid | productid | sales | AverageSales |
+---------+-----------+-------+--------------+
|       4 |       105 |    60 |      38.0000 |
|       6 |       104 |    50 |      38.0000 |
|       8 |       101 |    90 |      38.0000 |
|      10 |       102 |    60 |      38.0000 |
+---------+-----------+-------+--------------+


-----------------------------

MIN & MAX

Compare to Extremes analysis
	Compare current sales to the highest or lowest sales

Example:

SELECT 
	orderid, 
	productid, 
	sales, 
	MIN(sales) OVER () AS LowestSales, 
	MAX(sales) OVER () AS HighestSales 
FROM orders;
+---------+-----------+-------+-------------+--------------+
| orderid | productid | sales | LowestSales | HighestSales |
+---------+-----------+-------+-------------+--------------+
|       1 |       101 |    10 |          10 |           90 |
|       2 |       102 |    15 |          10 |           90 |
|       3 |       101 |    20 |          10 |           90 |
|       4 |       105 |    60 |          10 |           90 |
|       5 |       104 |    25 |          10 |           90 |
|       6 |       104 |    50 |          10 |           90 |
|       7 |       102 |    30 |          10 |           90 |
|       8 |       101 |    90 |          10 |           90 |
|       9 |       101 |    20 |          10 |           90 |
|      10 |       102 |    60 |          10 |           90 |
+---------+-----------+-------+-------------+--------------+

------------------------------------------------------------


SELECT 
	orderid, 
	orderdate, 
	productid, 
	sales, 
	MIN(COALESCE(sales, 0)) OVER () AS LowestSales, 
	MAX(COALESCE(sales, 0)) OVER () AS HighestSales, 
	MIN(COALESCE(sales, 0)) OVER (PARTITION BY productid) AS LowestSalesByProd, 
	MAX(COALESCE(sales, 0)) OVER (PARTITION BY productid) AS HighestSalesByProd 
FROM orders;
+---------+------------+-----------+-------+-------------+--------------+-------------------+--------------------+
| orderid | orderdate  | productid | sales | LowestSales | HighestSales | LowestSalesByProd | HighestSalesByProd |
+---------+------------+-----------+-------+-------------+--------------+-------------------+--------------------+
|       1 | 2025-01-01 |       101 |    10 |          10 |           90 |                10 |                 90 |
|       3 | 2025-01-10 |       101 |    20 |          10 |           90 |                10 |                 90 |
|       8 | 2025-02-18 |       101 |    90 |          10 |           90 |                10 |                 90 |
|       9 | 2025-03-10 |       101 |    20 |          10 |           90 |                10 |                 90 |
|       2 | 2025-01-05 |       102 |    15 |          10 |           90 |                15 |                 60 |
|       7 | 2025-02-15 |       102 |    30 |          10 |           90 |                15 |                 60 |
|      10 | 2025-03-15 |       102 |    60 |          10 |           90 |                15 |                 60 |
|       5 | 2025-02-01 |       104 |    25 |          10 |           90 |                25 |                 50 |
|       6 | 2025-02-05 |       104 |    50 |          10 |           90 |                25 |                 50 |
|       4 | 2025-01-20 |       105 |    60 |          10 |           90 |                60 |                 60 |
+---------+------------+-----------+-------+-------------+--------------+-------------------+--------------------+

-----------------------------------------------------------

Show the employees who have the highest salaries:

WITH HighestSalary AS (
	SELECT 
		*, 
		MAX(salary) OVER () AS HighestSalary 
	FROM employees
) SELECT * 
FROM HighestSalary 
WHERE salary = HighestSalary;
+------------+-----------+----------+------------+------------+--------+--------+-----------+---------------+
| employeeid | firstname | lastname | department | birthdate  | gender | salary | managerid | HighestSalary |
+------------+-----------+----------+------------+------------+--------+--------+-----------+---------------+
|          4 | Michael   | Ray      | Sales      | 1977-02-10 | M      |  90000 |         2 |         90000 |
+------------+-----------+----------+------------+------------+--------+--------+-----------+---------------+

-------------------------------------------------------------

Show deviation of each sales from the minimum and maximum sales amounts
(Lower is closest to value)

SELECT 
	orderid, 
	orderdate, 
	productid, 
	sales, 
	sales - MIN(COALESCE(sales, 0)) OVER () AS DevFromLowest, 
	MAX(COALESCE(sales, 0)) OVER () - sales AS DevFromHighest 
FROM orders;
+---------+------------+-----------+-------+---------------+----------------+
| orderid | orderdate  | productid | sales | DevFromLowest | DevFromHighest |
+---------+------------+-----------+-------+---------------+----------------+
|       1 | 2025-01-01 |       101 |    10 |             0 |             80 |
|       2 | 2025-01-05 |       102 |    15 |             5 |             75 |
|       3 | 2025-01-10 |       101 |    20 |            10 |             70 |
|       4 | 2025-01-20 |       105 |    60 |            50 |             30 |
|       5 | 2025-02-01 |       104 |    25 |            15 |             65 |
|       6 | 2025-02-05 |       104 |    50 |            40 |             40 |
|       7 | 2025-02-15 |       102 |    30 |            20 |             60 |
|       8 | 2025-02-18 |       101 |    90 |            80 |              0 |
|       9 | 2025-03-10 |       101 |    20 |            10 |             70 |
|      10 | 2025-03-15 |       102 |    60 |            50 |             30 |
+---------+------------+-----------+-------+---------------+----------------+

---------------------------------------------------------

Analytical Use Case: Running & Rolling Total

Running total: 
	Aggregate all values from the beginning up to the current point without
	dropping off older data.

Example:

SELECT 
	sales, 
	SUM(sales) OVER ( 
		ORDER BY MONTH(orderdate) 
		ROWS BETWEEN 
			UNBOUNDED PRECEDING 
			AND 
			CURRENT ROW 
	) AS SalesTotal  
FROM orders;
+-------+------------+
| sales | SalesTotal |
+-------+------------+
|    10 |         10 |
|    15 |         25 |
|    20 |         45 |
|    60 |        105 |
|    25 |        130 |
|    50 |        180 |
|    30 |        210 |
|    90 |        300 |
|    20 |        320 |
|    60 |        380 |
+-------+------------+

Rolling total:
	Aggregate all values within a fixed time window (Ex. 30 days)
	As new data is added, the oldest data point will be dropped.

????

---------------------------------------

Moving Average:

SELECT 
	orderid, 
	productid, 
	orderdate, 
	sales, 
	ROUND(AVG(sales) OVER (PARTITION BY productid)) AS AverageByProduct,
	ROUND(AVG(sales) OVER (PARTITION BY productid ORDER BY orderdate)) AS MovingAvg 
FROM orders;
+---------+-----------+------------+-------+------------------+-----------+
| orderid | productid | orderdate  | sales | AverageByProduct | MovingAvg |
+---------+-----------+------------+-------+------------------+-----------+
|       1 |       101 | 2025-01-01 |    10 |               35 |        10 |
|       3 |       101 | 2025-01-10 |    20 |               35 |        15 |
|       8 |       101 | 2025-02-18 |    90 |               35 |        40 |
|       9 |       101 | 2025-03-10 |    20 |               35 |        35 |
|       2 |       102 | 2025-01-05 |    15 |               35 |        15 |
|       7 |       102 | 2025-02-15 |    30 |               35 |        23 |
|      10 |       102 | 2025-03-15 |    60 |               35 |        35 |
|       5 |       104 | 2025-02-01 |    25 |               38 |        25 |
|       6 |       104 | 2025-02-05 |    50 |               38 |        38 |
|       4 |       105 | 2025-01-20 |    60 |               60 |        60 |
+---------+-----------+------------+-------+------------------+-----------+

------------------------------------------------------------

Rolling Average:

SELECT 
	orderid, 
	productid, 
	orderdate, 
	sales, 
	ROUND(AVG(sales) OVER (PARTITION BY productid)) AS AverageByProduct,
	ROUND(AVG(sales) OVER (PARTITION BY productid ORDER BY orderdate 
	ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING
	)) AS RollingAverage 
FROM orders;
+---------+-----------+------------+-------+------------------+----------------+
| orderid | productid | orderdate  | sales | AverageByProduct | RollingAverage |
+---------+-----------+------------+-------+------------------+----------------+
|       1 |       101 | 2025-01-01 |    10 |               35 |             15 |
|       3 |       101 | 2025-01-10 |    20 |               35 |             55 |
|       8 |       101 | 2025-02-18 |    90 |               35 |             55 |
|       9 |       101 | 2025-03-10 |    20 |               35 |             20 |
|       2 |       102 | 2025-01-05 |    15 |               35 |             23 |
|       7 |       102 | 2025-02-15 |    30 |               35 |             45 |
|      10 |       102 | 2025-03-15 |    60 |               35 |             60 |
|       5 |       104 | 2025-02-01 |    25 |               38 |             38 |
|       6 |       104 | 2025-02-05 |    50 |               38 |             50 |
|       4 |       105 | 2025-01-20 |    60 |               60 |             60 |
+---------+-----------+------------+-------+------------------+----------------+

---------------------------------------

Overall Total: 
	SUM(sales) OVER ()

Total Per Groups:
	SUM(sales) OVER (PARTITION BY productid)

Running Total:
	SUM(sales) OVER (ORDER BY Month)

Rolling Total:
	SUM(sales) OVER (
		ORDER BY Month
		ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
	)

Use with any aggregate functions.

---------------------------------------
