[Intermediate Level]

The following examples all use the database 'MyDatabase' from the collection 'sql-ultimate-course-main'

====================================================================

JOIN puts together by columns, side to side
Need common key column to combine

Recombine Data "Big Picture"

Data Enrichment "Getting extra Data"
Master Table <- JOIN Reference Table

Also, Check For Existence "filtering", filter data based on join,
such as filtering by only customers who ordered something

Not specifying a JOIN TYPE default is INNER
! Should always specify to make clearer!

---------------------------------------------------------------------

[Joins]

LEFT TABLE ( ), RIGHT TABLE ( ), BOTH ( ( ) )
(_) Matching, ( ) Unmatching

Basic Types:

INNER JOIN ( (_) )
Only matching rows from both Tables
SELECT * FROM TableA INNER JOIN TableB ON TableA.Key_Column = TableB.Key_Column

Example:

SELECT * FROM customers INNER JOIN orders ON customer_id = id;

-- Only customers that have placed an order (Exists in orders table)
+----+------------+---------+-------+----------+-------------+------------+-------+
| id | first_name | country | score | order_id | customer_id | order_date | sales |
+----+------------+---------+-------+----------+-------------+------------+-------+
|  1 | Maria      | Germany |   350 |     1001 |           1 | 2021-01-11 |    35 |
|  2 | John       | USA     |   900 |     1002 |           2 | 2021-04-05 |    15 |
|  3 | Georg      | UK      |   750 |     1003 |           3 | 2021-06-18 |    20 |
|  6 | Anya       | Ukraine |   350 |     1004 |           6 | 2021-08-31 |    10 |
+----+------------+---------+-------+----------+-------------+------------+-------+

-- Get only the needed columns, avoid redundancy:

SELECT id, first_name, country, score, order_id, order_date, sales 
FROM customers INNER JOIN orders ON customer_id = id;
+----+------------+---------+-------+----------+------------+-------+
| id | first_name | country | score | order_id | order_date | sales |
+----+------------+---------+-------+----------+------------+-------+
|  1 | Maria      | Germany |   350 |     1001 | 2021-01-11 |    35 |
|  2 | John       | USA     |   900 |     1002 | 2021-04-05 |    15 |
|  3 | Georg      | UK      |   750 |     1003 | 2021-06-18 |    20 |
|  6 | Anya       | Ukraine |   350 |     1004 | 2021-08-31 |    10 |
+----+------------+---------+-------+----------+------------+-------+

Column Ambiguity: Sometimes columns from 2 or more tables will have the same name.
Use the table Name. Column to avoid the error:

SELECT TableA.id, TableB.id FROM TableA INNER JOIN TableB ON TableA.id = TableB.id

Good practice to use table name before any column for many different columns in Query


Also, can use alias to save typing:

SELECT TA.id, TB.id FROM TableA AS TA INNER JOIN TableB AS TB ON TA.id = TB.id

Should definitely make names easy to use, but conveys information on what table they are an alias for.


----------------------------------------------------------------------

FULL JOIN (_(_)_)
Returns all rows from both tables

Order of tables doesn't matter

SELECT * FROM TableA AS TA FULL JOIN TableB AS TB ON TA.Key_Column = T B.Key_Column

=====================
!!! MySQL Problem !!!

From Gemini:

"Yes, Full Outer Join works differently in MySQL because MySQL does not natively support 
the FULL OUTER JOIN keyword as a direct operation like some other SQL database systems 
(e.g., PostgreSQL, SQL Server, Oracle).
Instead of a direct FULL OUTER JOIN, you need to emulate its behavior using a combination 
of LEFT JOIN, RIGHT JOIN, and the UNION operator."

Given Example:
"
SELECT columns
FROM table1
LEFT JOIN table2 ON table1.common_column = table2.common_column
UNION
SELECT columns
FROM table1
RIGHT JOIN table2 ON table1.common_column = table2.common_column
WHERE table1.common_column IS NULL;
"

"While the functionality of a full outer join is achievable in MySQL, 
the syntax and method of execution are different compared to databases 
that offer a direct FULL OUTER JOIN keyword."


Example:

SELECT * FROM customers LEFT JOIN orders ON id = customer_id 
UNION 
SELECT * FROM customers RIGHT JOIN orders ON id = customer_id WHERE id IS NULL;

+------+------------+---------+-------+----------+-------------+------------+-------+
| id   | first_name | country | score | order_id | customer_id | order_date | sales |
+------+------------+---------+-------+----------+-------------+------------+-------+
|    1 | Maria      | Germany |   350 |     1001 |           1 | 2021-01-11 |    35 |
|    2 | John       | USA     |   900 |     1002 |           2 | 2021-04-05 |    15 |
|    3 | Georg      | UK      |   750 |     1003 |           3 | 2021-06-18 |    20 |
|    4 | Martin     | Germany |   500 |     NULL |        NULL | NULL       |  NULL |
|    6 | Anya       | Ukraine |   350 |     1004 |           6 | 2021-08-31 |    10 |
|    7 | Masha      | Ukraine |   300 |     NULL |        NULL | NULL       |  NULL |
| NULL | NULL       | NULL    |  NULL |     1005 |           8 | 2021-09-15 |    25 |
+------+------------+---------+-------+----------+-------------+------------+-------+

!!!!!!!!!!!!!!!!!!!
===================

---------------------------------------------------------------------

LEFT JOIN (_(_) )
Returns all rows from left and only matching rows from right.

SELECT TA.id, TB.id FROM TableA AS TA LEFT JOIN TableB AS TB ON TA.id = TB.id

Example: 

SELECT id, first_name, country, score, order_id, order_date, sales 
FROM customers LEFT JOIN orders ON customer_id = id;

+----+------------+---------+-------+----------+------------+-------+
| id | first_name | country | score | order_id | order_date | sales |
+----+------------+---------+-------+----------+------------+-------+
|  1 | Maria      | Germany |   350 |     1001 | 2021-01-11 |    35 |
|  2 | John       | USA     |   900 |     1002 | 2021-04-05 |    15 |
|  3 | Georg      | UK      |   750 |     1003 | 2021-06-18 |    20 |
|  4 | Martin     | Germany |   500 |     NULL | NULL       |  NULL |
|  6 | Anya       | Ukraine |   350 |     1004 | 2021-08-31 |    10 |
|  7 | Masha      | Ukraine |   300 |     NULL | NULL       |  NULL |
+----+------------+---------+-------+----------+------------+-------+

There are NULLS in columns that did not exist in the right table (orders),
but all the rest of the columns from the left table (customers) are there.

Example with all columns:

SELECT * FROM customers LEFT JOIN orders ON customer_id = id;
+----+------------+---------+-------+----------+-------------+------------+-------+
| id | first_name | country | score | order_id | customer_id | order_date | sales |
+----+------------+---------+-------+----------+-------------+------------+-------+
|  1 | Maria      | Germany |   350 |     1001 |           1 | 2021-01-11 |    35 |
|  2 | John       | USA     |   900 |     1002 |           2 | 2021-04-05 |    15 |
|  3 | Georg      | UK      |   750 |     1003 |           3 | 2021-06-18 |    20 |
|  4 | Martin     | Germany |   500 |     NULL |        NULL | NULL       |  NULL |
|  6 | Anya       | Ukraine |   350 |     1004 |           6 | 2021-08-31 |    10 |
|  7 | Masha      | Ukraine |   300 |     NULL |        NULL | NULL       |  NULL |
+----+------------+---------+-------+----------+-------------+------------+-------+

Puts left table columns first, no matter what, then sees if match in right table.
Fills rest of right table columns with NULL if no match.

---------------------------------------------------------------------

RIGHT JOIN ( (_)_)
Returns all rows from the right and only matching rows from left

SELECT TA.id, TB.id FROM TableA AS TA RIGHT JOIN TableB AS TB ON TA.id = TB.id

Example:

(Updated orders table first so this example would be clearer):
INSERT INTO orders (order_id, customer_id, order_date, sales) VALUES (1005, 8, '2021-09-15', 25);


SELECT id, first_name, country, score, order_id, order_date, sales 
FROM customers RIGHT JOIN orders ON customer_id = id;

+------+------------+---------+-------+----------+------------+-------+
| id   | first_name | country | score | order_id | order_date | sales |
+------+------------+---------+-------+----------+------------+-------+
|    1 | Maria      | Germany |   350 |     1001 | 2021-01-11 |    35 |
|    2 | John       | USA     |   900 |     1002 | 2021-04-05 |    15 |
|    3 | Georg      | UK      |   750 |     1003 | 2021-06-18 |    20 |
|    6 | Anya       | Ukraine |   350 |     1004 | 2021-08-31 |    10 |
| NULL | NULL       | NULL    |  NULL |     1005 | 2021-09-15 |    25 |
+------+------------+---------+-------+----------+------------+-------+

Example with all columns:

SELECT * FROM customers RIGHT JOIN orders ON customer_id = id;

+------+------------+---------+-------+----------+-------------+------------+-------+
| id   | first_name | country | score | order_id | customer_id | order_date | sales |
+------+------------+---------+-------+----------+-------------+------------+-------+
|    1 | Maria      | Germany |   350 |     1001 |           1 | 2021-01-11 |    35 |
|    2 | John       | USA     |   900 |     1002 |           2 | 2021-04-05 |    15 |
|    3 | Georg      | UK      |   750 |     1003 |           3 | 2021-06-18 |    20 |
|    6 | Anya       | Ukraine |   350 |     1004 |           6 | 2021-08-31 |    10 |
| NULL | NULL       | NULL    |  NULL |     1005 |           8 | 2021-09-15 |    25 |
+------+------------+---------+-------+----------+-------------+------------+-------+

Puts right table columns first, no matter what, then sees if match in left table.
Fills rest of left table columns with NULL if no match.

---------------------------------------------------------------------

[Anti JOINS]

==================
!!! MySQL Note !!!

MySQL doesn't have an actual ANTI keyword for joins, but the same results can be gathered using
the kind of syntax shown in these examples:

"
AI Overview
Yes, MySQL supports anti-joins. While there isn't a specific ANTI JOIN keyword 
like some other database systems, the functionality of an anti-join can be achieved 
through various SQL constructs that MySQL's optimizer recognizes and can optimize 
into an anti-join strategy.

Here are the common ways to implement an anti-join in MySQL: 

    LEFT JOIN with WHERE IS NULL: This is a widely used and effective method. You perform a 
	LEFT JOIN from the "left" table to the "right" table and then filter the results in 
	the WHERE clause to include only those rows from the left table where there is no match 
	in the right table (i.e., the joined columns from the right table are NULL). 

Code

    SELECT t1.*
    FROM table1 t1
    LEFT JOIN table2 t2 ON t1.id = t2.id
    WHERE t2.id IS NULL;


    NOT EXISTS subquery: This approach checks for the non-existence of a correlated subquery.

Code

    SELECT t1.*
    FROM table1 t1
    WHERE NOT EXISTS (SELECT 1 FROM table2 t2 WHERE t1.id = t2.id);


    NOT IN subquery: While NOT IN can be less efficient with nullable columns, MySQL's 
	optimizer often rewrites NOT IN subqueries as NOT EXISTS for better performance.

Code

    SELECT t1.*
    FROM table1 t1
    WHERE t1.id NOT IN (SELECT t2.id FROM table2 t2);

MySQL's optimizer can transform these constructs into an internal anti-join operation, 
especially when dealing with NOT EXISTS and NOT IN subqueries, to improve query performance.
"

!!!!!!!!!!!!!!!!!
=================

LEFT ANTI JOIN (_( ) )
Returns rows from left that has no match in right

SELECT * FROM TableA AS TA LEFT JOIN TableB AS TB ON TA.Key_Column = TB.Key_Column 
WHERE TB.Key_Column IS NULL

Example:

SELECT * FROM customers LEFT JOIN orders ON customer_id = id WHERE customer_id IS NULL;
+----+------------+---------+-------+----------+-------------+------------+-------+
| id | first_name | country | score | order_id | customer_id | order_date | sales |
+----+------------+---------+-------+----------+-------------+------------+-------+
|  4 | Martin     | Germany |   500 |     NULL |        NULL | NULL       |  NULL |
|  7 | Masha      | Ukraine |   300 |     NULL |        NULL | NULL       |  NULL |
+----+------------+---------+-------+----------+-------------+------------+-------+

-- "Customers who haven't ordered anything"

---------------------------------------------------------------------

RIGHT ANTI JOIN ( ( )_)
Returns rows from right that has no match in left

SELECT * FROM TableA AS TA RIGHT JOIN TableB AS TB ON TA.Key_Column = TB.Key_Column 
WHERE TA.Key_Column IS NULL

Example:

SELECT * FROM customers RIGHT JOIN orders ON customer_id = id WHERE id IS NULL;
+------+------------+---------+-------+----------+-------------+------------+-------+
| id   | first_name | country | score | order_id | customer_id | order_date | sales |
+------+------------+---------+-------+----------+-------------+------------+-------+
| NULL | NULL       | NULL    |  NULL |     1005 |           8 | 2021-09-15 |    25 |
+------+------------+---------+-------+----------+-------------+------------+-------+

-- "Orders that don't have a customer associated with it"

Or With LEFT JOIN:

SELECT * FROM orders LEFT JOIN customers ON customer_id = id WHERE id IS NULL;
+----------+-------------+------------+-------+------+------------+---------+-------+
| order_id | customer_id | order_date | sales | id   | first_name | country | score |
+----------+-------------+------------+-------+------+------------+---------+-------+
|     1005 |           8 | 2021-09-15 |    25 | NULL | NULL       | NULL    |  NULL |
+----------+-------------+------------+-------+------+------------+---------+-------+

--------------------------------------------------------------------

FULL ANTI JOIN (_( )_)
Only the rows that don't match in either table

SELECT * FROM TableA AS TA FULL JOIN TableB AS TB ON TA.Key_Column = TB.Key_Column 
WHERE TA.Key_Column IS NULL OR TB.Key_Column IS NULL

=============
!!! MySQL !!!

No FULL JOIN, use this instead:

SELECT * FROM TableA AS TA LEFT JOIN TableB AS TB ON TA.Key_Column = TB.Key_Column 
WHERE TB.Key_Column IS NULL
UNION
SELECT * FROM TableA AS TA RIGHT JOIN TableB AS TB ON TA.Key_Column = TB.Key_Column 
WHERE TA.Key_Column IS NULL

Example:

SELECT * FROM customers LEFT JOIN orders ON id = customer_id WHERE customer_id IS NULL 
UNION 
SELECT * FROM customers RIGHT JOIN orders ON id = customer_id WHERE id IS NULL;
+------+------------+---------+-------+----------+-------------+------------+-------+
| id   | first_name | country | score | order_id | customer_id | order_date | sales |
+------+------------+---------+-------+----------+-------------+------------+-------+
|    4 | Martin     | Germany |   500 |     NULL |        NULL | NULL       |  NULL |
|    7 | Masha      | Ukraine |   300 |     NULL |        NULL | NULL       |  NULL |
| NULL | NULL       | NULL    |  NULL |     1005 |           8 | 2021-09-15 |    25 |
+------+------------+---------+-------+----------+-------------+------------+-------+

-- "Customers without orders and orders without customers"

---------------------------------------------------------------------

-- "Only customers who have placed an order" WITHOUT INNER JOIN:

SELECT * FROM orders LEFT JOIN customers ON customer_id = id WHERE id IS NOT NULL;
+----------+-------------+------------+-------+------+------------+---------+-------+
| order_id | customer_id | order_date | sales | id   | first_name | country | score |
+----------+-------------+------------+-------+------+------------+---------+-------+
|     1001 |           1 | 2021-01-11 |    35 |    1 | Maria      | Germany |   350 |
|     1002 |           2 | 2021-04-05 |    15 |    2 | John       | USA     |   900 |
|     1003 |           3 | 2021-06-18 |    20 |    3 | Georg      | UK      |   750 |
|     1004 |           6 | 2021-08-31 |    10 |    6 | Anya       | Ukraine |   350 |
+----------+-------------+------------+-------+------+------------+---------+-------+

---------------------------------------------------------------------

CROSS JOIN
Combines every row from left with every row from right
All possible combinations (Cartesian Join)

Good for testing purposes.

SELECT * FROM TableA CROSS JOIN TableB

Example:

SELECT * FROM customers CROSS JOIN orders;
+----+------------+---------+-------+----------+-------------+------------+-------+
| id | first_name | country | score | order_id | customer_id | order_date | sales |
+----+------------+---------+-------+----------+-------------+------------+-------+
|  1 | Maria      | Germany |   350 |     1005 |           8 | 2021-09-15 |    25 |
|  1 | Maria      | Germany |   350 |     1004 |           6 | 2021-08-31 |    10 |
|  1 | Maria      | Germany |   350 |     1003 |           3 | 2021-06-18 |    20 |
|  1 | Maria      | Germany |   350 |     1002 |           2 | 2021-04-05 |    15 |
|  1 | Maria      | Germany |   350 |     1001 |           1 | 2021-01-11 |    35 |
|  2 | John       | USA     |   900 |     1005 |           8 | 2021-09-15 |    25 |
|  2 | John       | USA     |   900 |     1004 |           6 | 2021-08-31 |    10 |
|  2 | John       | USA     |   900 |     1003 |           3 | 2021-06-18 |    20 |
|  2 | John       | USA     |   900 |     1002 |           2 | 2021-04-05 |    15 |
|  2 | John       | USA     |   900 |     1001 |           1 | 2021-01-11 |    35 |
|  3 | Georg      | UK      |   750 |     1005 |           8 | 2021-09-15 |    25 |
|  3 | Georg      | UK      |   750 |     1004 |           6 | 2021-08-31 |    10 |
|  3 | Georg      | UK      |   750 |     1003 |           3 | 2021-06-18 |    20 |
|  3 | Georg      | UK      |   750 |     1002 |           2 | 2021-04-05 |    15 |
|  3 | Georg      | UK      |   750 |     1001 |           1 | 2021-01-11 |    35 |
|  4 | Martin     | Germany |   500 |     1005 |           8 | 2021-09-15 |    25 |
|  4 | Martin     | Germany |   500 |     1004 |           6 | 2021-08-31 |    10 |
|  4 | Martin     | Germany |   500 |     1003 |           3 | 2021-06-18 |    20 |
|  4 | Martin     | Germany |   500 |     1002 |           2 | 2021-04-05 |    15 |
|  4 | Martin     | Germany |   500 |     1001 |           1 | 2021-01-11 |    35 |
|  6 | Anya       | Ukraine |   350 |     1005 |           8 | 2021-09-15 |    25 |
|  6 | Anya       | Ukraine |   350 |     1004 |           6 | 2021-08-31 |    10 |
|  6 | Anya       | Ukraine |   350 |     1003 |           3 | 2021-06-18 |    20 |
|  6 | Anya       | Ukraine |   350 |     1002 |           2 | 2021-04-05 |    15 |
|  6 | Anya       | Ukraine |   350 |     1001 |           1 | 2021-01-11 |    35 |
|  7 | Masha      | Ukraine |   300 |     1005 |           8 | 2021-09-15 |    25 |
|  7 | Masha      | Ukraine |   300 |     1004 |           6 | 2021-08-31 |    10 |
|  7 | Masha      | Ukraine |   300 |     1003 |           3 | 2021-06-18 |    20 |
|  7 | Masha      | Ukraine |   300 |     1002 |           2 | 2021-04-05 |    15 |
|  7 | Masha      | Ukraine |   300 |     1001 |           1 | 2021-01-11 |    35 |
+----+------------+---------+-------+----------+-------------+------------+-------+

---------------------------------------------------------------------
--------------------------------
How to choose between JOIN types
--------------------------------

Only matching? INNER JOIN

All Rows?
	One Side more important (Master table)? LEFT JOIN
	Both Important? FULL JOIN

Only unmatching data?
	One side more important (Master table)? LEFT ANTI JOIN
	Both important? FULL ANTI JOIN

RIGHT JOIN? Not really any need. :ON

--------------------------------
Multi_Table JOINs
--------------------------------

Master TableA LEFT JOIN TableB ON blah LEFT JOIN TableC ON blah etc.

WHERE clause to control final result (What to keep)

Get complete big picture.

Maybe only matching data important where there is no master table?
Use INNER JOINs instead (Overlapping between all tables)

---------------------------------------------------------------------
!!!! CHALLENGE !!!!!!!
---------------------------------------------------------------------
-- Using SalesDB, retrieve a list of all orders, along with the related
-- customer, product, and employee details
-- For each order, display:
-- Order ID, Customer's name, product name, sales amount, product price, and saleperson's name
-----------------------------------------------------------------------

Query:
SELECT o.orderid, c.firstname AS cust_first_name, c.lastname AS cust_last_name, 
p.product, o.sales, p.price, e.firstname AS empl_first_name, e.lastname AS empl_last_name
FROM orders AS o 
LEFT JOIN customers AS c ON c.customerid = o.customerid 
LEFT JOIN products AS p ON p.productid = o.productid 
LEFT JOIN employees AS e ON e.employeeid = o.salespersonid;

+---------+-----------------+----------------+---------+-------+-------+-----------------+----------------+
| orderid | cust_first_name | cust_last_name | product | sales | price | empl_first_name | empl_last_name |
+---------+-----------------+----------------+---------+-------+-------+-----------------+----------------+
|       1 | Kevin           | Brown          | Bottle  |    10 |    10 | Mary            | NULL           |
|       2 | Mary            | NULL           | Tire    |    15 |    15 | Mary            | NULL           |
|       3 | Jossef          | Goldberg       | Bottle  |    20 |    10 | Carol           | Baker          |
|       4 | Jossef          | Goldberg       | Gloves  |    60 |    30 | Mary            | NULL           |
|       5 | Kevin           | Brown          | Caps    |    25 |    25 | Carol           | Baker          |
|       6 | Mary            | NULL           | Caps    |    50 |    25 | Carol           | Baker          |
|       7 | Jossef          | Goldberg       | Tire    |    30 |    15 | Frank           | Lee            |
|       8 | Mark            | Schwarz        | Bottle  |    90 |    10 | Mary            | NULL           |
|       9 | Kevin           | Brown          | Bottle  |    20 |    10 | Mary            | NULL           |
|      10 | Mary            | NULL           | Tire    |    60 |    15 | Carol           | Baker          |
+---------+-----------------+----------------+---------+-------+-------+-----------------+----------------+


'orders' is master table, contains foreign keys found as all the primary keys in other tables, 
should use as starting point.

=====================================================================

SET puts together by rows, top to bottom
Need same number of columns to combine

---------------------------------------------------------------------

[Sets]

(Examples use the 'salesdb' database)

SELECT blah SET_OPERATOR SELECT blah

Rules:

SET operator can be used in almost all clauses, except for ORDER BY,
can only use this once at end of query.

The number of columns in each query must be the same.

The data types of columns in each query must match.

The order of columns in each query must be the same.

The column names in the result set are determined by the 
column names specified in the first query. (Controls aliases)

Even if all rules are met and SQL shows no errors,
the result may be incorrect. Incorrect column selection leads to
inaccurate results. You are responsible for mapping the correct information!

Basic Types:

---------------------------------------------------------------------

UNION
Returns all distinct rows from both queries.
Removes duplicate rows from results.

(_( )_)

SELECT * FROM TableA UNION SELECT * FROM TableB

Example:

SELECT firstname, lastname FROM customers 
UNION 
SELECT firstname, lastname FROM employees 
ORDER BY firstname;
+-----------+----------+
| firstname | lastname |
+-----------+----------+
| Anna      | Adams    |
| Carol     | Baker    |
| Frank     | Lee      |
| Jossef    | Goldberg |
| Kevin     | Brown    |
| Mark      | Schwarz  |
| Mary      | NULL     |
| Michael   | Ray      |
+-----------+----------+


---------------------------------------------------------------------

UNION All
Returns all rows from both queries, including duplicates.

(_(_)_)

UNION with duplicates, not distinct (everything).

Faster, since there is no need to look for duplicates.
Sure there are no duplicates to begin with? UNION ALL is faster choice!

SELECT * FROM TableA UNION ALL SELECT * FROM TableB

Example:

SELECT firstname, lastname FROM customers 
UNION ALL 
SELECT firstname, lastname FROM employees;
+-----------+----------+
| firstname | lastname |
+-----------+----------+
| Jossef    | Goldberg |
| Kevin     | Brown    |
| Mary      | NULL     |
| Mark      | Schwarz  |
| Anna      | Adams    |
| Frank     | Lee      |
| Kevin     | Brown    |
| Mary      | NULL     |
| Michael   | Ray      |
| Carol     | Baker    |
+-----------+----------+


---------------------------------------------------------------------

EXCEPT (MINUS)
Return all distinct rows from the first query that are not 
found in the second query.

(_( ) )

Everything in first query, EXCEPT (MINUS) the rows found in 2nd query.
If row in 2nd query matches ones in 1st query, removes them from result.
If row in 2nd query doesn't match, still don't include.
Results in whatever rows are remaining.

Order of queries is important!

Grabs from 1st query, uses 2nd query only as a check to filter out rows.

Example:

SELECT firstname, lastname FROM customers 
EXCEPT 
SELECT firstname, lastname FROM employees;
+-----------+----------+
| firstname | lastname |
+-----------+----------+
| Jossef    | Goldberg |
| Mark      | Schwarz  |
| Anna      | Adams    |
+-----------+----------+


---------------------------------------------------------------------

INTERSECT
Return only the distinct rows that are common in both queries.

( (_) )



The duplicates that would be removed in UNION.

Example:

SELECT firstname, lastname FROM customers 
INTERSECT 
SELECT firstname, lastname FROM employees;
+-----------+----------+
| firstname | lastname |
+-----------+----------+
| Kevin     | Brown    |
| Mary      | NULL     |
+-----------+----------+

-------------------------------------------------------------------
---------------------
UNION Use Cases
---------------------

Combine similar information before analyzing the data.

Can get inconsistent results if multiple queries and have to change them
regularly.

Instead, UNION them all into a new table, then apply queries to the new table.

Sometimes data is divided into multiple tables to optimize performance.
May need to combine them in order to work with all of them more easily.

Should never use '*' to list all columns, instead use the names explicitly.
What if some column name changes? Or a new column is added? Would be a problem
to map data with UNION using '*'.

Add extra information by using an alias to make clearer which originating table
the data belongs to:

SELECT 'TableA' AS SourceTable ...
UNION
SELECT 'TableB' AS SourceTable ...

Example:

SELECT 'CurrentOrders' AS SourceTable, orderid, productid, customerid 
FROM orders 
UNION 
SELECT 'OldOrders' AS SourceTable, orderid, productid, customerid 
FROM orders_archive;
+---------------+---------+-----------+------------+
| SourceTable   | orderid | productid | customerid |
+---------------+---------+-----------+------------+
| CurrentOrders |       1 |       101 |          2 |
| CurrentOrders |       2 |       102 |          3 |
| CurrentOrders |       3 |       101 |          1 |
| CurrentOrders |       4 |       105 |          1 |
| CurrentOrders |       5 |       104 |          2 |
| CurrentOrders |       6 |       104 |          3 |
| CurrentOrders |       7 |       102 |          1 |
| CurrentOrders |       8 |       101 |          4 |
| CurrentOrders |       9 |       101 |          2 |
| CurrentOrders |      10 |       102 |          3 |
| OldOrders     |       1 |       101 |          2 |
| OldOrders     |       2 |       102 |          3 |
| OldOrders     |       3 |       101 |          1 |
| OldOrders     |       4 |       105 |          1 |
| OldOrders     |       5 |       104 |          2 |
| OldOrders     |       6 |       104 |          3 |
| OldOrders     |       6 |       101 |          3 |
| OldOrders     |       7 |       102 |          3 |
+---------------+---------+-----------+------------+

------------------------------------------------------------------------

Delta Detection

Identifying the differences or changes (delta) between two batches of data.

Gets set of new orders, first time.
Gets set of second orders, now use EXCEPT to get the new data by comparison 
to then put the unique data into the 'Data Warehouse'.

-------------------------------------------------------------------------

Data Completeness Check

EXCEPT operator can be used to compare tables to detect discrepancies between databases.

Migrate Table from DatabaseA to DatabaseB.
Use EXCEPT between Table in DatabaseA and DatabaseB, if they match exactly,
then the result will be empty.
Use same DatabaseB -> DatabaseA.
If both results in empty, Tables match exactly.

---------------------------------------------------------------------------

Summary

Combine the results of multiple queries into a single result set.

Types: UNION, UNION ALL, EXCEPT, INTERSECT.

Rules:
	Same # of columns, Data Types, order of columns.
	1st query controls column names.

Use Cases:
	Combine information (UNION / UNION ALL)
	Delta Detection (EXCEPT)
	Data Completeness Check (EXCEPT)