[Advanced SQL Techniques]

----------------------------------------

Many different analysts writing complex queries to access a database,
along with data engineers: Extract, Transform, Load, put into Data Warehouse.

Data Warehouse: A special database that collects and integrates data from different
sources to enable analytics and support decision-making.

Data Analyst may query this DW, or it is queried to put into a visual report.

This system is called a 'Data Warehouse System' or 'Business Intelligence System'.

Also, Data Scientists may query and manipulate data for using models and possibly 
machine learning and AI.

Results of Data Analysis may query these results for other visual presentations.

----------------------

Challenges:

Each person is making their own queries, not communicating with each other.

But, a lot of redundant logic is being implemented by all of them.

All of these queries can hurt performance.

A data model may be prepared and optimized for only one purpose, so other analysts may have
a ton of questions for their own purposes, making things even more complex as it has to be
constantly explained.

This is all hard to maintain.

The DB also receives a lot of stress, and can crash.

Security can always be a problem as well. (DROP TABLE users SQL injection, anyone?)

---------------------

Simplified Database Architecture:

Database Engine: The brain of the database, executing multiple operations such as storing,
retrieving, and managing data within the database.

Disk Storage: Long-term memory, where data is stored permanently.

+Large Capacity
-Slow to read and write

User Data Storage: The main content of the database. This is where the actual data that users
care about is stored.

System Catalog: DB's internal storage for its own information.
A blueprint that keeps track of everything about the database itself, not the user data.
Holds metadata information about DB. 
metadata: 'Data about data'. (Such as the table schema)

Temp Data Storage: Temporary space used by the database for short-term tasks,
like processing queries or sorting data. Once these tasks are done, the storage is cleared.

---------------

Cache: Short-term memory, store data temporarily.

+Fast to read and write
-Can only store smaller amounts of memory

----------------------------------------

Data Engineer sends query to database engine.

Checks if it is in cache.

No? Then checks disk, queries, then sends it back to DE.

----------------------------------------

[Subqueries]

A query inside another query.

Subquery is inside main query.

Results of subquery stays inside main query, where the main query uses it in different ways.

SQL drops results of subquery when it is no longer in use.

-------------

Why subqueries?

1. JOIN Tables
2. Filtering
3. Transformations
4. Aggregations

Can make for long and complicated query.

Instead, one query for each step, all in one main query.

Main Query AKA Outer Query.

Subquery AKA Inner Query.

----------------------------------------

DB Engine executes the subquery first, result gets stored in the cache, where it
is fast to retrieve. Now it executes the main query, accessing the cache to get 
results of subquery. Then, after reporting results back, the cache is cleared.

----------------------------------------

Dependency:

---------

Non-Correlated Subquery:
	Independent from the main query.

Execution is straight-forward.
Executed once and its results are used by the main query.
Can be executed on its own.
Better performance.

Static comparisons, filtering with constants.

---------------------

Correlated Subquery:
	Dependent on the main query.
	Relies on values from the main query.
	
Cannot be executed on its own.
Bad performance.

Do row-by-row comparison, more dynamic filters.

Executes main query first, gets results row-by-row.
Passes value to subquery, gets results.
Now main query checks results, if given, output row in final result.
Repeat process until all rows processed.

Example:

-- Show all customer details and find the total orders of each customer:

SELECT 
	*, 
	(
		SELECT 
			COUNT(*) 
		FROM orders o 
		WHERE o.customerid = c.customerid
	) AS TotalSales 
FROM customers c;
+------------+-----------+----------+---------+-------+------------+
| customerid | firstname | lastname | country | score | TotalSales |
+------------+-----------+----------+---------+-------+------------+
|          1 | Jossef    | Goldberg | Germany |   350 |          3 |
|          2 | Kevin     | Brown    | USA     |   900 |          3 |
|          3 | Mary      | NULL     | USA     |   750 |          3 |
|          4 | Mark      | Schwarz  | Germany |   500 |          1 |
|          5 | Anna      | Adams    | USA     |  NULL |          0 |
+------------+-----------+----------+---------+-------+------------+

---------------------

Result Types:

------

Scalar

Like:

SELECT AVG(sales) FROM orders;
+------------+
| AVG(sales) |
+------------+
|    38.0000 |
+------------+


---------------------

Row

Like:

SELECT customerid FROM orders;
+------------+
| customerid |
+------------+
|          1 |
|          1 |
|          1 |
|          2 |
|          2 |
|          2 |
|          3 |
|          3 |
|          3 |
|          4 |
+------------+


---------------------

Table

Like:

SELECT customerid, sales FROM orders;
+------------+-------+
| customerid | sales |
+------------+-------+
|          2 |    10 |
|          3 |    15 |
|          1 |    20 |
|          1 |    60 |
|          2 |    25 |
|          3 |    50 |
|          1 |    30 |
|          4 |    90 |
|          2 |    20 |
|          3 |    60 |
+------------+-------+


----------------

Location|Clauses:

--------

SELECT

Used to aggregate the data side by side with the main query's data, allowing for direct comparison.

Only Scalar subqueries are allowed to be used!

SELECT 
	productid, 
	product, 
	price, 
	(SELECT COUNT(*) FROM orders) AS TotalOrders 
FROM products;
+-----------+---------+-------+-------------+
| productid | product | price | TotalOrders |
+-----------+---------+-------+-------------+
|       101 | Bottle  |    10 |          10 |
|       102 | Tire    |    15 |          10 |
|       103 | Socks   |    20 |          10 |
|       104 | Caps    |    25 |          10 |
|       105 | Gloves  |    30 |          10 |
+-----------+---------+-------+-------------+

---------------------

FROM

Use as temporary table for the main query.

Crap Example:

SELECT sales FROM (SELECT customerid, sales FROM orders) AS some_alias;
+-------+
| sales |
+-------+
|    10 |
|    15 |
|    20 |
|    60 |
|    25 |
|    50 |
|    30 |
|    90 |
|    20 |
|    60 |
+-------+

-- Find the products that have a price higher than the average price of all products:

SELECT * FROM (
	SELECT 
		productid, 
		price, 
		AVG(price) OVER () AS AvgPrice 
	FROM products
) AS subquery 
WHERE price > AvgPrice;
+-----------+-------+----------+
| productid | price | AvgPrice |
+-----------+-------+----------+
|       104 |    25 |  20.0000 |
|       105 |    30 |  20.0000 |
+-----------+-------+----------+

--Rank the customers based on thier otal amount of sales:

SELECT 
	*, 
	RANK() OVER (ORDER BY TotalSales DESC) AS CustomerRank 
	FROM (
		SELECT 
			customerid, 
			SUM(sales) AS TotalSales 
		FROM orders 
		GROUP BY customerid
	) AS subquery;
+------------+------------+--------------+
| customerid | TotalSales | CustomerRank |
+------------+------------+--------------+
|          3 |        125 |            1 |
|          1 |        110 |            2 |
|          4 |         90 |            3 |
|          2 |         55 |            4 |
+------------+------------+--------------+


---------------------

JOIN

Used to prepare the data (filtering or aggregation) before joining it with other tables.

-- Show all customer details and find the total orders of each customer:

SELECT 
	c.*, 
	o.TotalOrders 
FROM customers c 
LEFT JOIN (
	SELECT 
		customerid, 
		COUNT(*) AS TotalOrders 
	FROM orders 
	GROUP BY customerid
) AS o 
ON o.customerid = c.customerid;
+------------+-----------+----------+---------+-------+-------------+
| customerid | firstname | lastname | country | score | TotalOrders |
+------------+-----------+----------+---------+-------+-------------+
|          1 | Jossef    | Goldberg | Germany |   350 |           3 |
|          2 | Kevin     | Brown    | USA     |   900 |           3 |
|          3 | Mary      | NULL     | USA     |   750 |           3 |
|          4 | Mark      | Schwarz  | Germany |   500 |           1 |
|          5 | Anna      | Adams    | USA     |  NULL |        NULL |
+------------+-----------+----------+---------+-------+-------------+


---------------------

WHERE (Comparison or Logical operators)

Used for complex filtering logic and makes query more flexible and dynamic.

No aliases needed for subquery!

-----------------

Comparison:

Only scalar subqueries are allowed to be used!

-- Sales higher than average:

SELECT 
	customerid, 
	sales FROM orders 
WHERE sales > (
	SELECT AVG(sales) 
	FROM orders
);
+------------+-------+
| customerid | sales |
+------------+-------+
|          1 |    60 |
|          3 |    50 |
|          4 |    90 |
|          3 |    60 |
+------------+-------+

-- Find the products that have a price higher than the average price of all products

SELECT 
	productid, 
	price 
FROM products 
WHERE price > (
	SELECT AVG(price) 
	FROM products
);
+-----------+-------+
| productid | price |
+-----------+-------+
|       104 |    25 |
|       105 |    30 |
+-----------+-------+

-----------------

Logical:

The subquery is allowed to have multiple rows.

------------

IN

Checks whether a value matches any value from a list.

-- Show the details of orders made by customers in Germany:

SELECT 
	customerid, 
	orderid, 
	orderdate 
FROM orders 
WHERE customerid IN (
	SELECT 
		customerid 
	FROM customers 
	WHERE country = 'Germany'
);
+------------+---------+------------+
| customerid | orderid | orderdate  |
+------------+---------+------------+
|          1 |       3 | 2025-01-10 |
|          1 |       4 | 2025-01-20 |
|          1 |       7 | 2025-02-15 |
|          4 |       8 | 2025-02-18 |
+------------+---------+------------+

-- Not from Germany:

SELECT 
	customerid, 
	orderid, 
	orderdate 
FROM orders 
WHERE customerid NOT IN (
	SELECT 
		customerid 
	FROM customers 
	WHERE country = 'Germany'
);
+------------+---------+------------+
| customerid | orderid | orderdate  |
+------------+---------+------------+
|          2 |       1 | 2025-01-01 |
|          3 |       2 | 2025-01-05 |
|          2 |       5 | 2025-02-01 |
|          3 |       6 | 2025-02-05 |
|          2 |       9 | 2025-03-10 |
|          3 |      10 | 2025-03-15 |
+------------+---------+------------+

------------

ANY

Checks if a value matches ANY value within a list.

Used to check if a value is true for AT LEAST one of the values in a list.

-- Find female employees whose salaries are greater than the salaries of any male employee

SELECT 
	employeeid, 
	firstname, 
	salary 
FROM employees 
WHERE gender = 'F' 
AND salary > ANY (
	SELECT 
		salary 
	FROM employees 
	WHERE gender = 'M'
);
+------------+-----------+--------+
| employeeid | firstname | salary |
+------------+-----------+--------+
|          3 | Mary      |  75000 |
+------------+-----------+--------+

------------

ALL

Checks if a value matches ALL values within a list.

-- Find male employees whose salaries are greater than the salaries of all female employees:

SELECT 
	employeeid, 
	firstname, 
	salary 
FROM employees 
WHERE gender = 'M' 
AND salary > ALL (
	SELECT 
		salary 
	FROM employees 
	WHERE gender = 'F'
);
+------------+-----------+--------+
| employeeid | firstname | salary |
+------------+-----------+--------+
|          4 | Michael   |  90000 |
+------------+-----------+--------+

------------

EXISTS

Check if a subquery returns any rows.

For each row in Main Query:

Run subquery

No result? Row of main query excluded.

Returns value? Row of main query is included.

Often SELECT 1 is used because its value doesn't really matter and a static value is easier.

-- Show the order details for customers in Germany:

SELECT 
	orderid, 
	customerid, 
	orderdate 
FROM orders o 
WHERE EXISTS (
	SELECT 
		1 
	FROM customers c 
	WHERE country = 'Germany' AND o.customerid = c.customerid
);
+---------+------------+------------+
| orderid | customerid | orderdate  |
+---------+------------+------------+
|       3 |          1 | 2025-01-10 |
|       4 |          1 | 2025-01-20 |
|       7 |          1 | 2025-02-15 |
|       8 |          4 | 2025-02-18 |
+---------+------------+------------+

Use NOT EXISTS for customer not in Germany:

SELECT 
	orderid, 
	customerid, 
	orderdate 
FROM orders o 
WHERE NOT EXISTS (
	SELECT 
		1 
	FROM customers c 
	WHERE country = 'Germany' AND o.customerid = c.customerid
);
+---------+------------+------------+
| orderid | customerid | orderdate  |
+---------+------------+------------+
|       1 |          2 | 2025-01-01 |
|       2 |          3 | 2025-01-05 |
|       5 |          2 | 2025-02-01 |
|       6 |          3 | 2025-02-05 |
|       9 |          2 | 2025-03-10 |
|      10 |          3 | 2025-03-15 |
+---------+------------+------------+

----------------------------------------